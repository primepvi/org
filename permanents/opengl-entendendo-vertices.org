#+title: OpenGL - Entendendo Vértices
#+created_at: [2025-11-10]
#+edited_at: [2025-14-10]
#+tags: golang c data-structures

** Introdução

A primeira etapa do pipeline gráfico do OpenGL é o vertex shader, um pequeno programa que roda para cada vértice recebido na GPU, sendo sua principal função transformar a posição do vértice do espaço do modelo para o espaço de projeção da viewport (clip space), ele também é responsável por prover um output que servirá de input para o fragment shader.

** Vertex Attributes

Para o vertex shader efetuar seu trabalho corretamente ele precisa receber algumas informações importantes sobre o vértice, essas informações são chamadas de vertex attributes. O vertex shader precisa apenas de um Vec3 representando a posição do vértice no espaço do modelo, porém podemos passar também outros atributos como por exemplo um Vec3 representando a cor.

Segue abaixo um exemplo de atributos de vértices para um triângulo:

#+begin_src c
float vertices[] = {
  // x      y       z
	-0.5f,  -0.5f,   0.f, // vértice da esquerda
	 0.5f,  -0.5f,   0.f, // vértice da direita
	 0.f,    0.5f,   0.f, // vértice do topo
}
#+end_src

** Vertex Buffer Objects (VBOs)

Entretanto, vertex attributes por si só são apenas valores brutos que especificam os atributos da nossa renderização, para enviarmos isso para a GPU precisamos dos Vertex Buffer Objects (VBOs) que são uma maneira de armazenar uma coleção de vértices. Optamos por enviar coleções de vértices pelo fato da operação de envio de buffers para GPU ser extremamente custosa/lenta, portanto desejamos enviar o máximo de informação que conseguirmos de uma só vez. No OpenGL existem diversos tipos de buffers objects, sendo um deles o Array Buffer (GL_ARRAY_BUFFER) que é o que utilizamos para os VBOs.

O processo de criação de um vbo no OpenGL é bem simples, primeiro precisamos gerar um buffer, com o ID do buffer gerado fazemos a associação dele e inserimos os dados nesse buffer associado. No OpenGL é necessário especificar o tipo de tratamento que esse buffer irá receber, sendo esses tipos:

- *GL_STREAM_DRAW*: os *dados mudam sempre*;
- *GL_STATIC_DRAW*: os *dados não mudam* (*constantes*);
- *GL_DYNAMIC_DRAW*: os *dados podem mudar as vezes.*

Portanto, agora podemos criar um VBO para nossos atributos de vértice:

#+begin_src cpp
GLuint bufferId;
glGenBuffers(1, &bufferId);
if (bufferId == 0)
	throw std::runtime_error("Falha ao gerar o vbo");

glBindBuffer(GL_ARRAY_BUFFER, bufferId);
glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);
glBindBuffer(GL_ARRAY_BUFFER, 0); // unbind do buffer para evitar 
	// alterações não desejadas
#+end_src

** Vertex Array Objects (VAOs)

Contudo, com os VBOs por definição temos apenas fileiras de bits sem as configurações devidas para correta interpretação dos dados. Para resolvermos isso, precisamos definir como a GPU deve interpretar os vertex attributes utilizando os Vertex Array Objects (VAOs), que são responsáveis por armazenar apenas as configurações de interpretação dos dados.

Para criarmos um VAO é bem simples, primeiro precisamos gerar um vertex array e posteriormente fazer a associação com o ID gerado. Segue abaixo o exemplo:

#+begin_src cpp
GLuint vertexArrayId;
glGenVertexArrays(1, &vertexArrayId);
if (vertexArrayId == 0)
	throw std::runtime_error("Falha ao gerar o vao");

glBindVertexArray(vertexArrayId);
// configuração de interpretação dos vertex attributes aqui ...
glBindVertexArray(0); // unbind
#+end_src

Para definirmos as configurações de interpretação dos vertex attributes é bem simples, utilizamos a função `glVertexAttribPointer` ****para configurar um atributo e `glEnableVertexAttribArray` para ativar o atributo, veja os protótipos abaixo:

- *index*: índice do vertex attribute (*layout*);
- *size*: quantidade de elementos, *ex: (3 elementos de pos) (vec3)*;
- *type*: tipo opengl do elemento, *ex: (GL_FLOAT)*;
- *normalized*: se os elementos devem ser normalizados, *ex: (GL_TRUE ou GL_FALSE)*;
- *stride*: tamanho do buffer do atributo, *ex: (3 * sizeof(float))*
- *pointer*: ponteiro que representa o offset desde o inicio do vbo até o inicio do vertex attribute.

#+begin_src cpp
glVertexAttribPointer(index, size, type, normalized, stride, pointer)
glEnableVertexAttribArray(index)
#+end_src

Portanto, considere a imagem abaixo como representação do nosso VBO:

[[file:../assets/vaos.png]]
Temos um array com três vetores tridimensionais representando as posições dos vértices, portanto precisamos definir que temos um vertex attribute por vértice. Esse atributo possui 3 elementos do tipo float (GL_FLOAT), o stride é igual a quantidade de elementos multiplicado pelo tamanho de cada elemento (representa o tamanho do buffer do atributo de vértice), o index será 0 (representa o layout/índice do vertex attribute) e por último o normalized será false. Em suma, o código completo ficaria da seguinte maneira:

#+begin_src cpp
GLuint vertexArrayId;
glGenVertexArrays(1, &vertexArrayId);
if (vertexArrayId == 0)
	throw std::runtime_error("Falha ao gerar o vao");

glBindVertexArray(vertexArrayId);
glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, sizeof(float) * 3, NULL);
glEnableVertexAttribArray(0);
glBindVertexArray(0); // unbind
#+end_src

** Shaders

No OpenGL escrevemos os shaders utilizando a linguagem de shaders GLSL, portanto o código do nosso vertex shader ficaria assim:

#+begin_src glsl
 # version 330 core

// atributos de vértices, sendo o location o index do vertex attribute
layout (location = 0) in vec3 aPos;

out vec3 vColor; // será recebido como input no fragment shader

void main() {
	vColor = vec3(1.0, 0.0, 0.0); // vermelho
	gl_Position = vec4(aPos, 1.0); // posição do vértice
}
#+end_src

Segue abaixo o código do fragment shader:

#+begin_src glsl
#version 330 core

in vec3 vColor; // out do vertex shader
out vec4 FragColor;

void main() {
    FragColor = vec4(vColor, 1.0);
}
#+end_src

** Element Buffer Objects (EBOs)

Em alguns casos de desenhos mais complexos como por exemplo retângulos, cubos ou quadrados, podemos desenhar essas formas utilizando triângulos, entretanto pode acontecer de termos que definir vértices repetidos, trazendo assim um custo adicional desnecessário, para resolvermos esse problema podemos utilizar Element Buffer Objects (EBOs), que torna possível anexarmos nos VBOs apenas os vértices únicos. Isso é possível por conta que o estilo de desenho utilizado para EBOs é o desenho indexado, que consiste em você passar um EBO que contém os índices para cada vértice dos triângulo, dessa forma não é necessário repetir os vértices, pois a configuração de como cada vértice dos triângulos devem ser desenhados é passada no EBO.

[[file:../assets/ebos.png]]

Para criarmos um EBO é a mesma lógica dos buffers anteriores, geramos o buffer e associamos os dados com o ID gerado. Segue um exemplo abaixo:

#+begin_src glsl
float vertices[] = {
     0.5f,  0.5f, 0.0f,  // direita em cima
     0.5f, -0.5f, 0.0f,  // direita embaixo
    -0.5f, -0.5f, 0.0f,  // esquerda embaixo
    -0.5f,  0.5f, 0.0f   // esquerda em cima 
};

unsigned int indices[] = { 
    0, 1, 3,   // primeiro triângulo
    1, 2, 3    // segundo triângulo
}; 

GLuint elementBufferId;
glGenBuffers(1, &elementBufferId);
glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, elementBufferId);
glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(indices), indices, GL_STATIC_DRAW);  
#+end_src

** Desenhando os Vértices

Para desenharmos os vértices de fato, podemos utilizar dois métodos, sendo eles o `glDrawElements` para desenho indexado com EBOs, ou `glDrawArrays` para desenhar normalmente sem EBOs.

#+begin_src glsl
// desenho indexado (retângulo)
glBindVertexArray(vertexBufferId);
glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, 0);

// desenho normal (triângulo)
glBindVertexArray(vertexBufferId);
glDrawArrays(GL_TRIANGLES, 0, 3); 
#+end_src
